import os
import re
import smtplib
import ssl
import logging
import html
from typing import List, Tuple, Optional
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from app.config import (
    EMAIL_HOST, EMAIL_PORT, EMAIL_USERNAME, EMAIL_PASSWORD, 
    EMAIL_FROM, EMAIL_TO, EMAIL_SUBJECT
)

URL_RE = re.compile(r'https?://\S+')

def _clean_urls(urls):
    """Keep only usable Unsplash/Pexels photo page URLs, strip trailing punctuation."""
    cleaned = []
    for u in urls:
        u = u.rstrip(').,]>\'"')
        if ('unsplash.com/photos/' in u) or ('pexels.com/photo/' in u):
            cleaned.append(u)
    # de-duplicate, keep order
    seen = set()
    deduped = []
    for u in cleaned:
        if u not in seen:
            seen.add(u)
            deduped.append(u)
    return deduped

def parse_news_content(raw_content: str) -> List[dict]:
    """
    Parses LLM output that uses '---' separators and the sections:
    📰 (title), 🤖 (comment), 🖼️ Stock Images: (multi-line URLs), #️⃣ Hashtags:, 📌 Source:
    """
    logging.info("--- Parsing news content ---")
    news_items = []

    # Split by '---' blocks; LLM usually starts with '---'
    articles = [a for a in raw_content.strip().split('---') if a.strip()]

    for i, article_text in enumerate(articles):
        logging.info(f"Parsing article {i+1}...")
        item = {"images": []}

        # Only replace literal '\n' sequences, not every 'n'
        article_text = article_text.replace('\\n', '\n')

        # Normalize line endings and trim
        text = article_text.strip()

        # Title (📰 ... up to next marker)
        m = re.search(r'📰(.*?)(?:\n🤖|\n🖼️|#️⃣|📌|$)', text, re.DOTALL)
        if m:
            item['title'] = html.escape(m.group(1).strip())

        # Comment (🤖 ... up to next marker)
        m = re.search(r'🤖(.*?)(?:\n🖼️|#️⃣|📌|$)', text, re.DOTALL)
        if m:
            item['comment'] = html.escape(m.group(1).strip())

        # Images block: from '🖼️ Stock Images:' to next section
        m = re.search(r'🖼️\s*Stock Images:(.*?)(?:#️⃣|📌|$)', text, re.DOTALL | re.IGNORECASE)
        if m:
            block = m.group(1)
            urls = URL_RE.findall(block)
            item['images'] = _clean_urls(urls)
        else:
            logging.warning("No image section found for this article.")

        # Hashtags block: from '#️⃣ Hashtags:' to '📌' or end
        m = re.search(r'#️⃣\s*Hashtags:(.*?)(?:📌|$)', text, re.DOTALL | re.IGNORECASE)
        if m:
            item['hashtags'] = html.escape(m.group(1).strip())

        # Source line (may be wrong; we’ll override later)
        m = re.search(r'📌\s*Source:(.*)$', text, re.DOTALL | re.IGNORECASE)
        if m:
            item['source'] = html.escape(m.group(1).strip())

        news_items.append(item)

    logging.info("--- Finished parsing news content ---")
    return news_items

def _generate_email_body(news_items: List[dict], model_name: Optional[str] = None) -> Tuple[str, str]:
    """
    Creates HTML + plain text bodies.
    - Renders clickable anchors for image links.
    - Overrides the model name in Source if model_name is provided.
    """
    html_content = ""
    plain_text_content = ""

    for idx, item in enumerate(news_items, 1):
        title   = item.get('title', 'No Title')
        comment = item.get('comment', '')
        images  = item.get('images', [])
        hashtags = item.get('hashtags', '').strip()
        source  = item.get('source', 'Generated by AI (LLM model)')
        # Override/normalize source with the exact model, if provided
        if model_name:
            source = f"Generated by AI (LLM model: {model_name})"

        html_content += '<div class="news-item">'
        html_content += f'<div class="title">{title}</div>'
        html_content += f'<div class="comment"><pre>{comment}</pre></div>'

        if images:
            html_content += '<div class="images"><strong>Images:</strong><div>'
            for j, u in enumerate(images, 1):
                safe = html.escape(u, quote=True)
                html_content += f'<div><a href="{safe}" target="_blank" rel="noopener">Stock Image {j}</a></div>'
            html_content += '</div></div>'

        if hashtags:
            html_content += f'<div class="hashtags"><strong>Hashtags:</strong><pre>{hashtags}</pre></div>'

        html_content += f'<div class="source">Source: {html.escape(source)}</div>'
        html_content += '</div>'

        # Plain text
        plain_text_content += f"Title: {html.unescape(title)}\n"
        plain_text_content += f"Comment: {html.unescape(comment)}\n"
        if images:
            plain_text_content += "Images:\n" + "\n".join(images) + "\n"
        if hashtags:
            plain_text_content += f"Hashtags: {html.unescape(hashtags)}\n"
        plain_text_content += f"Source: {source}\n\n---\n\n"

    return html_content, plain_text_content

def send_email(subject: str, raw_content: str, model_name: Optional[str] = None):
    """
    Sends the email. Pass the exact model name from your API response here
    (e.g., model_name='sonar') to ensure the Source line is always correct.
    """
    logging.info("--- Preparing to send email ---")

    if not all([EMAIL_USERNAME, EMAIL_PASSWORD, EMAIL_TO]):
        logging.error("Email credentials or recipients not set in environment variables. Aborting.")
        return

    news_items = parse_news_content(raw_content)
    if not news_items:
        logging.info("No news items to send. Aborting.")
        return

    message = MIMEMultipart("alternative")
    message["Subject"] = subject
    message["From"] = EMAIL_FROM
    message["To"] = ", ".join(EMAIL_TO)

    # Load template
    try:
        template_path = os.path.join(os.path.dirname(__file__), '..', 'templates', 'email_template.html')
        with open(template_path, 'r', encoding='utf-8') as f:
            html_template = f.read()
        logging.info("Successfully loaded email template.")
    except FileNotFoundError:
        logging.error(f"email_template.html not found at {template_path}. Using plain text only.")
        html_template = ""

    html_body, plain_text_body = _generate_email_body(news_items, model_name=model_name)
    final_html = html_template.replace("{{news_items}}", html_body) if html_template else html_body

    part1 = MIMEText(plain_text_body, "plain", _charset="utf-8")
    part2 = MIMEText(final_html, "html", _charset="utf-8")
    message.attach(part1)
    message.attach(part2)

    logging.info("--- Connecting to SMTP server ---")
    context = ssl.create_default_context()
    try:
        with smtplib.SMTP_SSL(EMAIL_HOST, EMAIL_PORT, context=context) as server:
            server.login(EMAIL_USERNAME, EMAIL_PASSWORD)
            server.sendmail(EMAIL_FROM, EMAIL_TO, message.as_string())
            logging.info("Email sent successfully!")
    except smtplib.SMTPAuthenticationError as e:
        logging.error(f"SMTP Authentication Error: {e}. Please check your EMAIL_USERNAME and EMAIL_PASSWORD.")
    except Exception as e:
        logging.error(f"An error occurred while sending the email: {e}")